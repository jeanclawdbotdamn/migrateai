"""Chain Health Comparison Module — the foundation of migration analysis."""

import json
import sys
import os

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from apis.defillama import compare_chains, get_chain_health, get_all_chains
from apis.wormhole import get_token_bridge_support, assess_bridge_risk


def full_chain_comparison(source: str, target: str) -> dict:
    """
    Comprehensive chain-vs-chain analysis for migration decision.
    Combines DeFi Llama chain data + Wormhole bridge data.
    """
    # Chain fundamentals
    chain_comparison = compare_chains(source, target)
    if "error" in chain_comparison:
        return chain_comparison

    # Bridge connectivity
    bridge_data = get_token_bridge_support(source, target)

    # Bridge risk
    bridge_risk = assess_bridge_risk()

    # Compose full analysis
    result = {
        "analysis_type": "chain_comparison",
        "source_chain": chain_comparison["source"],
        "target_chain": chain_comparison["target"],
        "migration_signal": chain_comparison["migration_signal_score"],
        "migration_reasons": chain_comparison["migration_reasons"],
        "recommendation": chain_comparison["recommendation"],
        "bridge_connectivity": {
            "wormhole_supported": bridge_data.get("bridge_supported", False),
            "pair_transfers_30d": bridge_data.get("pair_transfers_30d", "unknown"),
            "network_24h_volume": bridge_data.get("network_24h_volume"),
        },
        "bridge_risk": {
            "level": bridge_risk.get("risk_level", "UNKNOWN"),
            "score": bridge_risk.get("risk_score", -1),
            "tvl": bridge_risk.get("tvl"),
        },
    }

    # Overall migration feasibility score (0-100)
    feasibility = chain_comparison["migration_signal_score"]

    # Bonus for strong bridge support
    if bridge_data.get("bridge_supported"):
        feasibility = min(feasibility + 10, 100)
    else:
        feasibility = max(feasibility - 20, 0)

    # Penalty for bridge risk
    if bridge_risk.get("risk_level") == "HIGH":
        feasibility = max(feasibility - 15, 0)

    result["feasibility_score"] = feasibility
    result["feasibility_grade"] = (
        "A" if feasibility >= 80 else
        "B" if feasibility >= 60 else
        "C" if feasibility >= 40 else
        "D" if feasibility >= 20 else "F"
    )

    return result


def generate_chain_report(source: str, target: str) -> str:
    """Generate human-readable migration report."""
    data = full_chain_comparison(source, target)

    if "error" in data:
        return f"Error: {json.dumps(data, indent=2)}"

    src = data["source_chain"]
    tgt = data["target_chain"]

    report = f"""# Migration Analysis: {src['chain']} → {tgt['chain']}
*Generated by MigrateAI*

## Feasibility: Grade {data['feasibility_grade']} ({data['feasibility_score']}/100)

### Source Chain: {src['chain']}
- TVL: {src['tvl_formatted']}
- Protocols: {src['protocol_count']}
- 30-day TVL change: {src['tvl_change_30d_pct']:.1f}%
- Trend: **{src['tvl_trend'].upper()}**

### Target Chain: {tgt['chain']}
- TVL: {tgt['tvl_formatted']}
- Protocols: {tgt['protocol_count']}
- 30-day TVL change: {tgt['tvl_change_30d_pct']:.1f}%
- Trend: **{tgt['tvl_trend'].upper()}**

### Migration Signal: {data['migration_signal']}/100
"""
    for reason in data["migration_reasons"]:
        report += f"- {reason}\n"

    report += f"""
### Bridge Connectivity (Wormhole)
- Wormhole support: {'✅ Yes' if data['bridge_connectivity']['wormhole_supported'] else '❌ No'}
- 30-day transfers on this pair: {data['bridge_connectivity'].get('pair_transfers_30d', 'N/A')}
- Network 24h volume: ${float(data['bridge_connectivity'].get('network_24h_volume', 0))/1e6:.1f}M

### Bridge Risk: {data['bridge_risk']['level']}
- TVL locked: ${float(data['bridge_risk'].get('tvl', 0))/1e9:.2f}B

### Recommendation
**{data['recommendation']}**
"""
    return report


def scan_dying_chains(threshold_pct: float = -10.0) -> list:
    """Find chains with declining TVL — migration candidates."""
    chains = get_all_chains()
    if isinstance(chains, dict) and "error" in chains:
        return []

    dying = []
    for chain in chains:
        if chain.get("tvl", 0) > 1e6:  # Only chains with >$1M TVL
            health = get_chain_health(chain["name"])
            if isinstance(health, dict) and health.get("tvl_change_30d_pct", 0) < threshold_pct:
                dying.append(health)

    return sorted(dying, key=lambda x: x.get("tvl_change_30d_pct", 0))


if __name__ == "__main__":
    if len(sys.argv) > 2:
        print(generate_chain_report(sys.argv[1], sys.argv[2]))
    elif len(sys.argv) > 1 and sys.argv[1] == "--dying":
        dying = scan_dying_chains()
        for chain in dying[:10]:
            print(f"  {chain['chain']}: {chain['tvl_formatted']} ({chain['tvl_change_30d_pct']:.1f}% 30d)")
    else:
        print("Usage: python chain_health.py <source_chain> <target_chain>")
        print("       python chain_health.py --dying")
