"""Code Generator â€” generates Solana Anchor project scaffolding from EVM contract patterns."""

import json
import os
from datetime import datetime


def generate_anchor_project(project_name: str, contract_types: list, source_chain: str = "EVM") -> dict:
    """
    Generate a complete Anchor project scaffold for migrating EVM contracts to Solana.
    Returns a dict of {filepath: content} representing the project structure.
    """
    slug = project_name.lower().replace(" ", "_").replace("-", "_")
    files = {}

    # Anchor.toml
    files["Anchor.toml"] = f"""[toolchain]
anchor_version = "0.31.1"

[features]
resolution = true
skip-lint = false

[programs.localnet]
{slug} = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[programs.devnet]
{slug} = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[registry]
url = "https://api.apr.dev"

[provider]
cluster = "Localnet"
wallet = "~/.config/solana/id.json"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"
"""

    # Cargo.toml
    files[f"programs/{slug}/Cargo.toml"] = f"""[package]
name = "{slug}"
version = "0.1.0"
description = "Migrated from {source_chain} using MigrateAI"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "{slug}"

[features]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
cpi = ["no-entrypoint"]
default = []

[dependencies]
anchor-lang = "0.31.1"
anchor-spl = "0.31.1"
"""

    # Generate program lib.rs based on contract types
    lib_rs = generate_lib_rs(slug, contract_types, source_chain)
    files[f"programs/{slug}/src/lib.rs"] = lib_rs

    # Generate state modules
    for ct in contract_types:
        ct_lower = ct.lower().replace("/", "_").replace("-", "_").replace(" ", "_")
        state_mod = generate_state_module(ct, slug)
        if state_mod:
            files[f"programs/{slug}/src/state/{ct_lower}.rs"] = state_mod

    # State mod.rs
    state_mods = []
    for ct in contract_types:
        ct_lower = ct.lower().replace("/", "_").replace("-", "_").replace(" ", "_")
        state_mods.append(f"pub mod {ct_lower};")
    files[f"programs/{slug}/src/state/mod.rs"] = "\n".join(state_mods) + "\n"

    # Instructions mod.rs
    ix_mods = []
    for ct in contract_types:
        ct_lower = ct.lower().replace("/", "_").replace("-", "_").replace(" ", "_")
        ix_mod = generate_instruction_module(ct, slug)
        if ix_mod:
            files[f"programs/{slug}/src/instructions/{ct_lower}.rs"] = ix_mod
            ix_mods.append(f"pub mod {ct_lower};")
    files[f"programs/{slug}/src/instructions/mod.rs"] = "\n".join(ix_mods) + "\n"

    # Error codes
    files[f"programs/{slug}/src/errors.rs"] = generate_errors(contract_types)

    # Tests
    files[f"tests/{slug}.ts"] = generate_tests(slug, contract_types)

    # Package.json
    files["package.json"] = json.dumps({
        "scripts": {"test": "anchor test"},
        "dependencies": {
            "@coral-xyz/anchor": "^0.31.1",
            "@solana/web3.js": "^1.95.0",
            "@solana/spl-token": "^0.4.0",
        },
        "devDependencies": {
            "chai": "^4.3.4",
            "mocha": "^9.0.3",
            "ts-mocha": "^10.0.0",
            "@types/chai": "^4.3.0",
            "typescript": "^5.0.0",
        }
    }, indent=2)

    # tsconfig
    files["tsconfig.json"] = json.dumps({
        "compilerOptions": {
            "types": ["mocha", "chai"],
            "typeRoots": ["./node_modules/@types"],
            "lib": ["es2015"],
            "module": "commonjs",
            "target": "es6",
            "esModuleInterop": True
        }
    }, indent=2)

    # Wormhole NTT config if bridge-related
    if any(ct.lower() in ("erc-20", "erc-721", "bridge") for ct in contract_types):
        files["ntt/deployment.json"] = generate_ntt_config(slug, source_chain)

    # Migration guide
    files["MIGRATION.md"] = generate_migration_guide(project_name, contract_types, source_chain)

    return files


def generate_lib_rs(slug: str, contract_types: list, source: str) -> str:
    """Generate the main lib.rs with program entry points."""
    code = f"""//! {slug} â€” Solana program migrated from {source}
//! Generated by MigrateAI (https://github.com/jeanclawdbotdamn/migrateai)
//!
//! ## Migration Notes (EVM â†’ Solana)
//! - EVM storage slots â†’ Solana accounts (PDAs)
//! - msg.sender â†’ Signer constraint
//! - require() â†’ Anchor constraints + custom errors
//! - Events â†’ Anchor events (emit!)
//! - block.timestamp â†’ Clock::get()
//! - mappings â†’ PDA derivation with seeds

use anchor_lang::prelude::*;
use anchor_spl::token::{{self, Token, TokenAccount, Mint, Transfer, MintTo, Burn}};

pub mod state;
pub mod instructions;
pub mod errors;

use instructions::*;
use errors::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod {slug} {{
    use super::*;

"""
    # Add instruction handlers based on contract types
    for ct in contract_types:
        code += generate_instruction_handlers(ct)

    code += "}\n"
    return code


def generate_instruction_handlers(contract_type: str) -> str:
    """Generate instruction handler stubs for a contract type."""
    handlers = {
        "ERC-20": """
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TOKEN (migrated from ERC-20)
    // EVM: transfer(), approve(), transferFrom()
    // Solana: SPL Token handles most of this natively
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /// Initialize the token mint
    /// EVM equivalent: constructor() in ERC-20
    pub fn initialize_token(
        ctx: Context<InitializeToken>,
        decimals: u8,
        name: String,
        symbol: String,
    ) -> Result<()> {
        let config = &mut ctx.accounts.config;
        config.authority = ctx.accounts.authority.key();
        config.mint = ctx.accounts.mint.key();
        config.name = name;
        config.symbol = symbol;
        config.decimals = decimals;
        config.total_supply = 0;
        Ok(())
    }

    /// Mint tokens to an account
    /// EVM equivalent: _mint() internal function
    pub fn mint_tokens(ctx: Context<MintTokens>, amount: u64) -> Result<()> {
        let config = &mut ctx.accounts.config;
        config.total_supply = config.total_supply.checked_add(amount)
            .ok_or(ErrorCode::Overflow)?;

        let seeds = &[b"config".as_ref(), &[ctx.bumps.config]];
        let signer = &[&seeds[..]];

        token::mint_to(
            CpiContext::new_with_signer(
                ctx.accounts.token_program.to_account_info(),
                MintTo {
                    mint: ctx.accounts.mint.to_account_info(),
                    to: ctx.accounts.destination.to_account_info(),
                    authority: ctx.accounts.config.to_account_info(),
                },
                signer,
            ),
            amount,
        )?;

        emit!(TokensMinted {
            to: ctx.accounts.destination.key(),
            amount,
        });
        Ok(())
    }

""",
        "AMM/DEX": """
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AMM / DEX (migrated from Uniswap V2-style)
    // EVM: addLiquidity(), removeLiquidity(), swap()
    // Solana: Pool state in PDA, token accounts owned by pool
    // Key diff: No reentrancy risk, CPI for token transfers
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /// Initialize a liquidity pool
    /// EVM equivalent: createPair() in Factory
    pub fn initialize_pool(
        ctx: Context<InitializePool>,
        fee_bps: u16,  // Fee in basis points (e.g., 30 = 0.3%)
    ) -> Result<()> {
        require!(fee_bps <= 10000, ErrorCode::InvalidFee);

        let pool = &mut ctx.accounts.pool;
        pool.token_a_mint = ctx.accounts.token_a_mint.key();
        pool.token_b_mint = ctx.accounts.token_b_mint.key();
        pool.token_a_vault = ctx.accounts.token_a_vault.key();
        pool.token_b_vault = ctx.accounts.token_b_vault.key();
        pool.lp_mint = ctx.accounts.lp_mint.key();
        pool.fee_bps = fee_bps;
        pool.authority = ctx.accounts.authority.key();
        pool.total_lp_supply = 0;
        pool.bump = ctx.bumps.pool;

        emit!(PoolCreated {
            pool: pool.key(),
            token_a: pool.token_a_mint,
            token_b: pool.token_b_mint,
            fee_bps,
        });
        Ok(())
    }

    /// Add liquidity to pool
    /// EVM equivalent: addLiquidity() in Router
    pub fn add_liquidity(
        ctx: Context<AddLiquidity>,
        amount_a: u64,
        amount_b: u64,
        min_lp_tokens: u64,
    ) -> Result<()> {
        let pool = &ctx.accounts.pool;

        // Calculate LP tokens to mint (simplified constant product)
        let reserve_a = ctx.accounts.token_a_vault.amount;
        let reserve_b = ctx.accounts.token_b_vault.amount;

        let lp_tokens = if pool.total_lp_supply == 0 {
            // Initial liquidity: sqrt(amount_a * amount_b)
            ((amount_a as u128) * (amount_b as u128)).integer_sqrt() as u64
        } else {
            // Proportional: min(amount_a/reserve_a, amount_b/reserve_b) * total_supply
            let lp_a = (amount_a as u128)
                .checked_mul(pool.total_lp_supply as u128).unwrap()
                .checked_div(reserve_a as u128).unwrap() as u64;
            let lp_b = (amount_b as u128)
                .checked_mul(pool.total_lp_supply as u128).unwrap()
                .checked_div(reserve_b as u128).unwrap() as u64;
            std::cmp::min(lp_a, lp_b)
        };

        require!(lp_tokens >= min_lp_tokens, ErrorCode::SlippageExceeded);

        // Transfer tokens to vault (CPI to SPL Token)
        // EVM diff: In Solidity you'd call transferFrom(). Here we use CPI.
        token::transfer(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info(),
                Transfer {
                    from: ctx.accounts.user_token_a.to_account_info(),
                    to: ctx.accounts.token_a_vault.to_account_info(),
                    authority: ctx.accounts.user.to_account_info(),
                },
            ),
            amount_a,
        )?;

        token::transfer(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info(),
                Transfer {
                    from: ctx.accounts.user_token_b.to_account_info(),
                    to: ctx.accounts.token_b_vault.to_account_info(),
                    authority: ctx.accounts.user.to_account_info(),
                },
            ),
            amount_b,
        )?;

        // Mint LP tokens
        let pool_key = ctx.accounts.pool.key();
        let seeds = &[b"pool".as_ref(), pool_key.as_ref(), &[pool.bump]];
        let signer = &[&seeds[..]];

        token::mint_to(
            CpiContext::new_with_signer(
                ctx.accounts.token_program.to_account_info(),
                MintTo {
                    mint: ctx.accounts.lp_mint.to_account_info(),
                    to: ctx.accounts.user_lp.to_account_info(),
                    authority: ctx.accounts.pool.to_account_info(),
                },
                signer,
            ),
            lp_tokens,
        )?;

        // Update pool state
        let pool = &mut ctx.accounts.pool;
        pool.total_lp_supply = pool.total_lp_supply.checked_add(lp_tokens)
            .ok_or(ErrorCode::Overflow)?;

        emit!(LiquidityAdded {
            pool: pool.key(),
            provider: ctx.accounts.user.key(),
            amount_a,
            amount_b,
            lp_tokens,
        });
        Ok(())
    }

    /// Swap tokens (constant product AMM)
    /// EVM equivalent: swapExactTokensForTokens() in Router
    pub fn swap(
        ctx: Context<Swap>,
        amount_in: u64,
        minimum_out: u64,
        a_to_b: bool,
    ) -> Result<()> {
        let pool = &ctx.accounts.pool;

        // Get reserves
        let reserve_in = if a_to_b {
            ctx.accounts.token_a_vault.amount
        } else {
            ctx.accounts.token_b_vault.amount
        };
        let reserve_out = if a_to_b {
            ctx.accounts.token_b_vault.amount
        } else {
            ctx.accounts.token_a_vault.amount
        };

        // Calculate output: x * y = k (constant product)
        // amount_out = (amount_in * fee_factor * reserve_out) / (reserve_in + amount_in * fee_factor)
        let fee_factor = 10000u128 - pool.fee_bps as u128;
        let amount_in_with_fee = (amount_in as u128) * fee_factor;
        let numerator = amount_in_with_fee * (reserve_out as u128);
        let denominator = (reserve_in as u128) * 10000 + amount_in_with_fee;
        let amount_out = (numerator / denominator) as u64;

        require!(amount_out >= minimum_out, ErrorCode::SlippageExceeded);

        // Execute swap via CPI
        // ... (transfer in, transfer out with PDA signer)

        emit!(SwapExecuted {
            pool: pool.key(),
            user: ctx.accounts.user.key(),
            amount_in,
            amount_out,
            a_to_b,
        });
        Ok(())
    }

""",
        "Staking": """
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STAKING (migrated from EVM staking contract)
    // EVM: stake(), unstake(), claimReward()
    // Solana: Stake accounts + PDA reward tracking
    // Key diff: No block.timestamp, use Clock sysvar
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /// Initialize staking pool
    pub fn initialize_staking(
        ctx: Context<InitializeStaking>,
        reward_rate: u64,  // Rewards per second per staked token
    ) -> Result<()> {
        let staking = &mut ctx.accounts.staking_pool;
        staking.authority = ctx.accounts.authority.key();
        staking.staking_mint = ctx.accounts.staking_mint.key();
        staking.reward_mint = ctx.accounts.reward_mint.key();
        staking.reward_rate = reward_rate;
        staking.total_staked = 0;
        // EVM diff: block.timestamp â†’ Clock::get()
        staking.last_update_time = Clock::get()?.unix_timestamp;
        staking.reward_per_token_stored = 0;
        staking.bump = ctx.bumps.staking_pool;
        Ok(())
    }

    /// Stake tokens
    /// EVM equivalent: stake(uint256 amount)
    pub fn stake(ctx: Context<Stake>, amount: u64) -> Result<()> {
        let staking = &mut ctx.accounts.staking_pool;
        let user_stake = &mut ctx.accounts.user_stake;
        let clock = Clock::get()?;

        // Update rewards (EVM: modifier updateReward)
        _update_rewards(staking, user_stake, clock.unix_timestamp)?;

        // Transfer tokens to vault
        token::transfer(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info(),
                Transfer {
                    from: ctx.accounts.user_token.to_account_info(),
                    to: ctx.accounts.staking_vault.to_account_info(),
                    authority: ctx.accounts.user.to_account_info(),
                },
            ),
            amount,
        )?;

        user_stake.amount = user_stake.amount.checked_add(amount)
            .ok_or(ErrorCode::Overflow)?;
        staking.total_staked = staking.total_staked.checked_add(amount)
            .ok_or(ErrorCode::Overflow)?;

        emit!(Staked {
            user: ctx.accounts.user.key(),
            amount,
        });
        Ok(())
    }

    /// Claim staking rewards
    /// EVM equivalent: claimReward()
    pub fn claim_rewards(ctx: Context<ClaimRewards>) -> Result<()> {
        let staking = &mut ctx.accounts.staking_pool;
        let user_stake = &mut ctx.accounts.user_stake;
        let clock = Clock::get()?;

        _update_rewards(staking, user_stake, clock.unix_timestamp)?;

        let reward = user_stake.rewards_earned;
        if reward > 0 {
            user_stake.rewards_earned = 0;
            // Mint reward tokens via PDA signer
            // ... (CPI mint_to with pool PDA authority)
        }

        emit!(RewardsClaimed {
            user: ctx.accounts.user.key(),
            amount: reward,
        });
        Ok(())
    }

""",
        "Governance/DAO": """
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // GOVERNANCE (migrated from Governor/Timelock)
    // EVM: propose(), vote(), execute()
    // Solana: Use Realms (SPL Governance) or custom
    // Recommendation: Use Realms SDK for production
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /// Create a governance proposal
    pub fn create_proposal(
        ctx: Context<CreateProposal>,
        title: String,
        description: String,
        voting_period: i64,  // seconds
    ) -> Result<()> {
        let proposal = &mut ctx.accounts.proposal;
        let clock = Clock::get()?;

        proposal.proposer = ctx.accounts.proposer.key();
        proposal.title = title;
        proposal.description = description;
        proposal.start_time = clock.unix_timestamp;
        proposal.end_time = clock.unix_timestamp + voting_period;
        proposal.yes_votes = 0;
        proposal.no_votes = 0;
        proposal.executed = false;
        proposal.proposal_id = ctx.accounts.governance.proposal_count;

        let governance = &mut ctx.accounts.governance;
        governance.proposal_count += 1;

        Ok(())
    }

    /// Cast a vote on a proposal
    pub fn vote(ctx: Context<Vote>, support: bool) -> Result<()> {
        let proposal = &mut ctx.accounts.proposal;
        let clock = Clock::get()?;

        require!(clock.unix_timestamp <= proposal.end_time, ErrorCode::VotingEnded);

        let vote_weight = ctx.accounts.voter_token_account.amount;

        if support {
            proposal.yes_votes = proposal.yes_votes.checked_add(vote_weight)
                .ok_or(ErrorCode::Overflow)?;
        } else {
            proposal.no_votes = proposal.no_votes.checked_add(vote_weight)
                .ok_or(ErrorCode::Overflow)?;
        }
        Ok(())
    }

""",
        "Oracle Consumer": """
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ORACLE CONSUMER (migrated from Chainlink)
    // EVM: AggregatorV3Interface.latestRoundData()
    // Solana: Pyth price accounts passed as instruction args
    // Key diff: Pull model, prices in account data
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /// Read price from Pyth oracle
    /// EVM equivalent: getLatestPrice() using Chainlink
    pub fn read_price(ctx: Context<ReadPrice>) -> Result<()> {
        // Pyth price feed account is passed as remaining account
        // In EVM you'd call: priceFeed.latestRoundData()
        // In Solana: read account data directly

        // Example with pyth-sdk-solana:
        // let price_feed = &ctx.accounts.pyth_price_feed;
        // let price = price_feed.get_price_unchecked();
        // let price_val = price.price;
        // let confidence = price.conf;
        // let expo = price.expo;

        msg!("Price read from Pyth oracle");
        Ok(())
    }

""",
    }

    ct_key = contract_type
    if ct_key not in handlers:
        # Generic handler
        slug = contract_type.lower().replace("/", "_").replace("-", "_").replace(" ", "_")
        return f"""
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // {contract_type.upper()} (custom migration)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    pub fn initialize_{slug}(ctx: Context<Initialize{slug.title().replace('_', '')}>) -> Result<()> {{
        // TODO: Implement {contract_type} initialization
        // Map your EVM constructor logic here
        Ok(())
    }}

"""

    return handlers.get(ct_key, "")


def generate_state_module(contract_type: str, slug: str) -> str:
    """Generate state account structs for a contract type."""
    states = {
        "ERC-20": f"""use anchor_lang::prelude::*;

/// Token configuration (replaces ERC-20 contract state)
/// EVM: name, symbol, decimals, totalSupply stored in contract
/// Solana: Stored in a PDA account
#[account]
#[derive(InitSpace)]
pub struct TokenConfig {{
    pub authority: Pubkey,      // EVM: owner()
    pub mint: Pubkey,           // The SPL token mint
    #[max_len(32)]
    pub name: String,           // EVM: name()
    #[max_len(8)]
    pub symbol: String,         // EVM: symbol()
    pub decimals: u8,           // EVM: decimals()
    pub total_supply: u64,      // EVM: totalSupply()
}}

// EVM events â†’ Anchor events
#[event]
pub struct TokensMinted {{
    pub to: Pubkey,
    pub amount: u64,
}}
""",
        "AMM/DEX": f"""use anchor_lang::prelude::*;

/// Liquidity pool state (replaces Uniswap Pair contract)
/// EVM: reserve0, reserve1, totalSupply stored in Pair contract
/// Solana: Reserves are SPL token account balances, pool state in PDA
#[account]
#[derive(InitSpace)]
pub struct Pool {{
    pub token_a_mint: Pubkey,
    pub token_b_mint: Pubkey,
    pub token_a_vault: Pubkey,    // EVM: stored implicitly in contract balance
    pub token_b_vault: Pubkey,    // Solana: explicit token accounts
    pub lp_mint: Pubkey,          // EVM: ERC-20 LP token
    pub fee_bps: u16,             // Fee in basis points
    pub authority: Pubkey,
    pub total_lp_supply: u64,
    pub bump: u8,
}}

#[event]
pub struct PoolCreated {{
    pub pool: Pubkey,
    pub token_a: Pubkey,
    pub token_b: Pubkey,
    pub fee_bps: u16,
}}

#[event]
pub struct LiquidityAdded {{
    pub pool: Pubkey,
    pub provider: Pubkey,
    pub amount_a: u64,
    pub amount_b: u64,
    pub lp_tokens: u64,
}}

#[event]
pub struct SwapExecuted {{
    pub pool: Pubkey,
    pub user: Pubkey,
    pub amount_in: u64,
    pub amount_out: u64,
    pub a_to_b: bool,
}}
""",
        "Staking": f"""use anchor_lang::prelude::*;

/// Staking pool configuration
/// EVM: StakingRewards contract state
/// Solana: PDA account with reward tracking
#[account]
#[derive(InitSpace)]
pub struct StakingPool {{
    pub authority: Pubkey,
    pub staking_mint: Pubkey,
    pub reward_mint: Pubkey,
    pub reward_rate: u64,              // Rewards per second
    pub total_staked: u64,
    pub last_update_time: i64,         // EVM: lastUpdateTime (block.timestamp)
    pub reward_per_token_stored: u128, // Accumulated rewards per token
    pub bump: u8,
}}

/// Per-user stake info
/// EVM: mapping(address => UserInfo)
/// Solana: Separate PDA per user (derived from user pubkey)
#[account]
#[derive(InitSpace)]
pub struct UserStake {{
    pub user: Pubkey,
    pub amount: u64,                          // EVM: balanceOf[user]
    pub rewards_earned: u64,                  // Unclaimed rewards
    pub reward_per_token_paid: u128,          // Last checkpoint
}}

#[event]
pub struct Staked {{
    pub user: Pubkey,
    pub amount: u64,
}}

#[event]
pub struct RewardsClaimed {{
    pub user: Pubkey,
    pub amount: u64,
}}
""",
        "Governance/DAO": f"""use anchor_lang::prelude::*;

#[account]
#[derive(InitSpace)]
pub struct Governance {{
    pub authority: Pubkey,
    pub token_mint: Pubkey,
    pub proposal_count: u64,
    pub quorum: u64,
}}

#[account]
#[derive(InitSpace)]
pub struct Proposal {{
    pub proposer: Pubkey,
    #[max_len(64)]
    pub title: String,
    #[max_len(256)]
    pub description: String,
    pub start_time: i64,
    pub end_time: i64,
    pub yes_votes: u64,
    pub no_votes: u64,
    pub executed: bool,
    pub proposal_id: u64,
}}
""",
    }

    return states.get(contract_type, f"""use anchor_lang::prelude::*;

/// {contract_type} state â€” customize for your migration
#[account]
#[derive(InitSpace)]
pub struct {contract_type.replace('/', '').replace('-', '').replace(' ', '')}State {{
    pub authority: Pubkey,
    pub initialized: bool,
    pub bump: u8,
}}
""")


def generate_instruction_module(contract_type: str, slug: str) -> str:
    """Generate instruction account validation structs."""
    if contract_type == "ERC-20":
        return f"""use anchor_lang::prelude::*;
use anchor_spl::token::{{Token, TokenAccount, Mint}};
use crate::state::erc_20::*;

#[derive(Accounts)]
pub struct InitializeToken<'info> {{
    #[account(mut)]
    pub authority: Signer<'info>,

    #[account(
        init,
        payer = authority,
        space = 8 + TokenConfig::INIT_SPACE,
        seeds = [b"config"],
        bump,
    )]
    pub config: Account<'info, TokenConfig>,

    #[account(
        init,
        payer = authority,
        mint::decimals = 9,
        mint::authority = config,
    )]
    pub mint: Account<'info, Mint>,

    pub token_program: Program<'info, Token>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>,
}}

#[derive(Accounts)]
pub struct MintTokens<'info> {{
    pub authority: Signer<'info>,

    #[account(
        mut,
        seeds = [b"config"],
        bump,
        has_one = authority,
    )]
    pub config: Account<'info, TokenConfig>,

    #[account(mut, constraint = mint.key() == config.mint)]
    pub mint: Account<'info, Mint>,

    #[account(mut)]
    pub destination: Account<'info, TokenAccount>,

    pub token_program: Program<'info, Token>,
}}
"""
    elif contract_type == "AMM/DEX":
        return f"""use anchor_lang::prelude::*;
use anchor_spl::token::{{Token, TokenAccount, Mint}};
use crate::state::amm_dex::*;

#[derive(Accounts)]
pub struct InitializePool<'info> {{
    #[account(mut)]
    pub authority: Signer<'info>,

    #[account(
        init,
        payer = authority,
        space = 8 + Pool::INIT_SPACE,
        seeds = [b"pool", token_a_mint.key().as_ref(), token_b_mint.key().as_ref()],
        bump,
    )]
    pub pool: Account<'info, Pool>,

    pub token_a_mint: Account<'info, Mint>,
    pub token_b_mint: Account<'info, Mint>,

    #[account(
        init,
        payer = authority,
        token::mint = token_a_mint,
        token::authority = pool,
    )]
    pub token_a_vault: Account<'info, TokenAccount>,

    #[account(
        init,
        payer = authority,
        token::mint = token_b_mint,
        token::authority = pool,
    )]
    pub token_b_vault: Account<'info, TokenAccount>,

    #[account(
        init,
        payer = authority,
        mint::decimals = 9,
        mint::authority = pool,
    )]
    pub lp_mint: Account<'info, Mint>,

    pub token_program: Program<'info, Token>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>,
}}

#[derive(Accounts)]
pub struct AddLiquidity<'info> {{
    #[account(mut)]
    pub user: Signer<'info>,

    #[account(mut)]
    pub pool: Account<'info, Pool>,

    #[account(mut, constraint = token_a_vault.key() == pool.token_a_vault)]
    pub token_a_vault: Account<'info, TokenAccount>,
    #[account(mut, constraint = token_b_vault.key() == pool.token_b_vault)]
    pub token_b_vault: Account<'info, TokenAccount>,

    #[account(mut)]
    pub user_token_a: Account<'info, TokenAccount>,
    #[account(mut)]
    pub user_token_b: Account<'info, TokenAccount>,
    #[account(mut)]
    pub user_lp: Account<'info, TokenAccount>,

    #[account(mut, constraint = lp_mint.key() == pool.lp_mint)]
    pub lp_mint: Account<'info, Mint>,

    pub token_program: Program<'info, Token>,
}}

#[derive(Accounts)]
pub struct Swap<'info> {{
    #[account(mut)]
    pub user: Signer<'info>,
    #[account(mut)]
    pub pool: Account<'info, Pool>,
    #[account(mut)]
    pub token_a_vault: Account<'info, TokenAccount>,
    #[account(mut)]
    pub token_b_vault: Account<'info, TokenAccount>,
    #[account(mut)]
    pub user_token_in: Account<'info, TokenAccount>,
    #[account(mut)]
    pub user_token_out: Account<'info, TokenAccount>,
    pub token_program: Program<'info, Token>,
}}
"""
    return None


def generate_errors(contract_types: list) -> str:
    """Generate error codes."""
    return """use anchor_lang::prelude::*;

#[error_code]
pub enum ErrorCode {
    #[msg("Arithmetic overflow")]
    Overflow,
    #[msg("Slippage tolerance exceeded")]
    SlippageExceeded,
    #[msg("Invalid fee: must be <= 10000 bps")]
    InvalidFee,
    #[msg("Insufficient balance")]
    InsufficientBalance,
    #[msg("Unauthorized")]
    Unauthorized,
    #[msg("Voting period has ended")]
    VotingEnded,
    #[msg("Already initialized")]
    AlreadyInitialized,
}
"""


def generate_tests(slug: str, contract_types: list) -> str:
    """Generate TypeScript test file."""
    return f"""import * as anchor from "@coral-xyz/anchor";
import {{ Program }} from "@coral-xyz/anchor";
import {{ {slug.title().replace('_', '')} }} from "../target/types/{slug}";
import {{ expect }} from "chai";

describe("{slug}", () => {{
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.{slug.title().replace('_', '')} as Program<{slug.title().replace('_', '')}>;

  it("Initializes successfully", async () => {{
    // TODO: Add initialization test
    console.log("Program ID:", program.programId.toString());
  }});

  // TODO: Add tests for each migrated contract function
  // Tip: Use anchor.web3.Keypair.generate() for test accounts
  // Tip: Use getAssociatedTokenAddress() for token accounts
}});
"""


def generate_ntt_config(slug: str, source_chain: str) -> str:
    """Generate Wormhole NTT deployment config."""
    return json.dumps({
        "_comment": f"Wormhole NTT config for {slug} migration from {source_chain}",
        "_docs": "https://wormhole.com/docs/products/token-transfers/native-token-transfers/",
        "network": "Mainnet",
        "chains": {
            source_chain.lower(): {
                "mode": "burning",
                "manager": "<DEPLOY_NTT_MANAGER_ADDRESS>",
                "token": "<SOURCE_TOKEN_ADDRESS>",
                "transceiver": {
                    "type": "wormhole",
                    "address": "<DEPLOY_TRANSCEIVER_ADDRESS>"
                }
            },
            "solana": {
                "mode": "burning",
                "manager": "<DEPLOY_NTT_MANAGER_PROGRAM_ID>",
                "token": "<NEW_SPL_TOKEN_MINT>",
                "transceiver": {
                    "type": "wormhole",
                    "address": "<DEPLOY_TRANSCEIVER_PROGRAM_ID>"
                }
            }
        },
        "rateLimits": {
            "outbound": "1000000000000",
            "inbound": "1000000000000"
        }
    }, indent=2)


def generate_migration_guide(project_name: str, contract_types: list, source: str) -> str:
    """Generate a project-specific migration guide."""
    now = datetime.utcnow().strftime("%Y-%m-%d")
    guide = f"""# Migration Guide: {project_name}
## {source} â†’ Solana
*Generated by MigrateAI on {now}*

## What Was Generated

This Anchor project contains scaffolding for migrating the following contract types:
"""
    for ct in contract_types:
        guide += f"- **{ct}**\n"

    guide += f"""
## EVM â†’ Solana Key Concepts

| EVM Concept | Solana Equivalent |
|---|---|
| Contract storage | Account data (PDAs) |
| msg.sender | Signer constraint |
| require() | Anchor constraints + #[error_code] |
| Events | emit! macro |
| block.timestamp | Clock::get()?.unix_timestamp |
| mapping(address => X) | PDA per key (seeds = [user.key()]) |
| ERC-20 balances | Associated Token Accounts |
| approve/transferFrom | Delegate + CPI to SPL Token |
| Reentrancy guard | Not needed (single-threaded) |
| Gas optimization | Compute Unit optimization |
| Constructor | initialize instruction |

## Getting Started

```bash
# Install dependencies
yarn install

# Build the program
anchor build

# Run tests
anchor test

# Deploy to devnet
anchor deploy --provider.cluster devnet
```

## Bridge Setup (Wormhole NTT)

If you need to bridge tokens from {source}:

1. Edit `ntt/deployment.json` with your token addresses
2. Follow Wormhole NTT docs: https://wormhole.com/docs/products/token-transfers/native-token-transfers/
3. Deploy NTT Manager on both chains
4. Configure rate limits

## Next Steps

1. [ ] Replace placeholder program ID with your deployed ID
2. [ ] Implement remaining business logic in each instruction
3. [ ] Add comprehensive tests
4. [ ] Run `anchor verify` before mainnet deployment
5. [ ] Get a security audit (recommended: OtterSec, Sec3, Neodyme)

---
*Generated by MigrateAI â€” https://github.com/jeanclawdbotdamn/migrateai*
"""
    return guide


def _update_rewards(staking, user_stake, timestamp):
    """Helper to update reward calculations (used by staking)."""
    # This would be in a separate utils module in production
    pass


if __name__ == "__main__":
    import sys
    project = sys.argv[1] if len(sys.argv) > 1 else "MyProject"
    types = sys.argv[2:] if len(sys.argv) > 2 else ["ERC-20", "AMM/DEX", "Staking"]

    files = generate_anchor_project(project, types, "Ethereum")
    print(f"Generated {len(files)} files for {project}:")
    for path in sorted(files.keys()):
        lines = files[path].count('\n')
        print(f"  ğŸ“„ {path} ({lines} lines)")

    # Optionally write to disk
    if "--write" in sys.argv:
        out_dir = f"generated/{project.lower().replace(' ', '_')}"
        for path, content in files.items():
            full_path = os.path.join(out_dir, path)
            os.makedirs(os.path.dirname(full_path), exist_ok=True)
            with open(full_path, 'w') as f:
                f.write(content)
        print(f"\nâœ… Written to {out_dir}/")
