//! spookyswap — Solana program migrated from Ethereum
//! Generated by MigrateAI (https://github.com/jeanclawdbotdamn/migrateai)
//!
//! ## Migration Notes (EVM → Solana)
//! - EVM storage slots → Solana accounts (PDAs)
//! - msg.sender → Signer constraint
//! - require() → Anchor constraints + custom errors
//! - Events → Anchor events (emit!)
//! - block.timestamp → Clock::get()
//! - mappings → PDA derivation with seeds

use anchor_lang::prelude::*;
use anchor_spl::token::{self, Token, TokenAccount, Mint, Transfer, MintTo, Burn};

pub mod state;
pub mod instructions;
pub mod errors;

use instructions::*;
use errors::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod spookyswap {
    use super::*;


    // ═══════════════════════════════════════════════════
    // TOKEN (migrated from ERC-20)
    // EVM: transfer(), approve(), transferFrom()
    // Solana: SPL Token handles most of this natively
    // ═══════════════════════════════════════════════════

    /// Initialize the token mint
    /// EVM equivalent: constructor() in ERC-20
    pub fn initialize_token(
        ctx: Context<InitializeToken>,
        decimals: u8,
        name: String,
        symbol: String,
    ) -> Result<()> {
        let config = &mut ctx.accounts.config;
        config.authority = ctx.accounts.authority.key();
        config.mint = ctx.accounts.mint.key();
        config.name = name;
        config.symbol = symbol;
        config.decimals = decimals;
        config.total_supply = 0;
        Ok(())
    }

    /// Mint tokens to an account
    /// EVM equivalent: _mint() internal function
    pub fn mint_tokens(ctx: Context<MintTokens>, amount: u64) -> Result<()> {
        let config = &mut ctx.accounts.config;
        config.total_supply = config.total_supply.checked_add(amount)
            .ok_or(ErrorCode::Overflow)?;

        let seeds = &[b"config".as_ref(), &[ctx.bumps.config]];
        let signer = &[&seeds[..]];

        token::mint_to(
            CpiContext::new_with_signer(
                ctx.accounts.token_program.to_account_info(),
                MintTo {
                    mint: ctx.accounts.mint.to_account_info(),
                    to: ctx.accounts.destination.to_account_info(),
                    authority: ctx.accounts.config.to_account_info(),
                },
                signer,
            ),
            amount,
        )?;

        emit!(TokensMinted {
            to: ctx.accounts.destination.key(),
            amount,
        });
        Ok(())
    }


    // ═══════════════════════════════════════════════════
    // AMM / DEX (migrated from Uniswap V2-style)
    // EVM: addLiquidity(), removeLiquidity(), swap()
    // Solana: Pool state in PDA, token accounts owned by pool
    // Key diff: No reentrancy risk, CPI for token transfers
    // ═══════════════════════════════════════════════════

    /// Initialize a liquidity pool
    /// EVM equivalent: createPair() in Factory
    pub fn initialize_pool(
        ctx: Context<InitializePool>,
        fee_bps: u16,  // Fee in basis points (e.g., 30 = 0.3%)
    ) -> Result<()> {
        require!(fee_bps <= 10000, ErrorCode::InvalidFee);

        let pool = &mut ctx.accounts.pool;
        pool.token_a_mint = ctx.accounts.token_a_mint.key();
        pool.token_b_mint = ctx.accounts.token_b_mint.key();
        pool.token_a_vault = ctx.accounts.token_a_vault.key();
        pool.token_b_vault = ctx.accounts.token_b_vault.key();
        pool.lp_mint = ctx.accounts.lp_mint.key();
        pool.fee_bps = fee_bps;
        pool.authority = ctx.accounts.authority.key();
        pool.total_lp_supply = 0;
        pool.bump = ctx.bumps.pool;

        emit!(PoolCreated {
            pool: pool.key(),
            token_a: pool.token_a_mint,
            token_b: pool.token_b_mint,
            fee_bps,
        });
        Ok(())
    }

    /// Add liquidity to pool
    /// EVM equivalent: addLiquidity() in Router
    pub fn add_liquidity(
        ctx: Context<AddLiquidity>,
        amount_a: u64,
        amount_b: u64,
        min_lp_tokens: u64,
    ) -> Result<()> {
        let pool = &ctx.accounts.pool;

        // Calculate LP tokens to mint (simplified constant product)
        let reserve_a = ctx.accounts.token_a_vault.amount;
        let reserve_b = ctx.accounts.token_b_vault.amount;

        let lp_tokens = if pool.total_lp_supply == 0 {
            // Initial liquidity: sqrt(amount_a * amount_b)
            ((amount_a as u128) * (amount_b as u128)).integer_sqrt() as u64
        } else {
            // Proportional: min(amount_a/reserve_a, amount_b/reserve_b) * total_supply
            let lp_a = (amount_a as u128)
                .checked_mul(pool.total_lp_supply as u128).unwrap()
                .checked_div(reserve_a as u128).unwrap() as u64;
            let lp_b = (amount_b as u128)
                .checked_mul(pool.total_lp_supply as u128).unwrap()
                .checked_div(reserve_b as u128).unwrap() as u64;
            std::cmp::min(lp_a, lp_b)
        };

        require!(lp_tokens >= min_lp_tokens, ErrorCode::SlippageExceeded);

        // Transfer tokens to vault (CPI to SPL Token)
        // EVM diff: In Solidity you'd call transferFrom(). Here we use CPI.
        token::transfer(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info(),
                Transfer {
                    from: ctx.accounts.user_token_a.to_account_info(),
                    to: ctx.accounts.token_a_vault.to_account_info(),
                    authority: ctx.accounts.user.to_account_info(),
                },
            ),
            amount_a,
        )?;

        token::transfer(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info(),
                Transfer {
                    from: ctx.accounts.user_token_b.to_account_info(),
                    to: ctx.accounts.token_b_vault.to_account_info(),
                    authority: ctx.accounts.user.to_account_info(),
                },
            ),
            amount_b,
        )?;

        // Mint LP tokens
        let pool_key = ctx.accounts.pool.key();
        let seeds = &[b"pool".as_ref(), pool_key.as_ref(), &[pool.bump]];
        let signer = &[&seeds[..]];

        token::mint_to(
            CpiContext::new_with_signer(
                ctx.accounts.token_program.to_account_info(),
                MintTo {
                    mint: ctx.accounts.lp_mint.to_account_info(),
                    to: ctx.accounts.user_lp.to_account_info(),
                    authority: ctx.accounts.pool.to_account_info(),
                },
                signer,
            ),
            lp_tokens,
        )?;

        // Update pool state
        let pool = &mut ctx.accounts.pool;
        pool.total_lp_supply = pool.total_lp_supply.checked_add(lp_tokens)
            .ok_or(ErrorCode::Overflow)?;

        emit!(LiquidityAdded {
            pool: pool.key(),
            provider: ctx.accounts.user.key(),
            amount_a,
            amount_b,
            lp_tokens,
        });
        Ok(())
    }

    /// Swap tokens (constant product AMM)
    /// EVM equivalent: swapExactTokensForTokens() in Router
    pub fn swap(
        ctx: Context<Swap>,
        amount_in: u64,
        minimum_out: u64,
        a_to_b: bool,
    ) -> Result<()> {
        let pool = &ctx.accounts.pool;

        // Get reserves
        let reserve_in = if a_to_b {
            ctx.accounts.token_a_vault.amount
        } else {
            ctx.accounts.token_b_vault.amount
        };
        let reserve_out = if a_to_b {
            ctx.accounts.token_b_vault.amount
        } else {
            ctx.accounts.token_a_vault.amount
        };

        // Calculate output: x * y = k (constant product)
        // amount_out = (amount_in * fee_factor * reserve_out) / (reserve_in + amount_in * fee_factor)
        let fee_factor = 10000u128 - pool.fee_bps as u128;
        let amount_in_with_fee = (amount_in as u128) * fee_factor;
        let numerator = amount_in_with_fee * (reserve_out as u128);
        let denominator = (reserve_in as u128) * 10000 + amount_in_with_fee;
        let amount_out = (numerator / denominator) as u64;

        require!(amount_out >= minimum_out, ErrorCode::SlippageExceeded);

        // Execute swap via CPI
        // ... (transfer in, transfer out with PDA signer)

        emit!(SwapExecuted {
            pool: pool.key(),
            user: ctx.accounts.user.key(),
            amount_in,
            amount_out,
            a_to_b,
        });
        Ok(())
    }


    // ═══════════════════════════════════════════════════
    // STAKING (migrated from EVM staking contract)
    // EVM: stake(), unstake(), claimReward()
    // Solana: Stake accounts + PDA reward tracking
    // Key diff: No block.timestamp, use Clock sysvar
    // ═══════════════════════════════════════════════════

    /// Initialize staking pool
    pub fn initialize_staking(
        ctx: Context<InitializeStaking>,
        reward_rate: u64,  // Rewards per second per staked token
    ) -> Result<()> {
        let staking = &mut ctx.accounts.staking_pool;
        staking.authority = ctx.accounts.authority.key();
        staking.staking_mint = ctx.accounts.staking_mint.key();
        staking.reward_mint = ctx.accounts.reward_mint.key();
        staking.reward_rate = reward_rate;
        staking.total_staked = 0;
        // EVM diff: block.timestamp → Clock::get()
        staking.last_update_time = Clock::get()?.unix_timestamp;
        staking.reward_per_token_stored = 0;
        staking.bump = ctx.bumps.staking_pool;
        Ok(())
    }

    /// Stake tokens
    /// EVM equivalent: stake(uint256 amount)
    pub fn stake(ctx: Context<Stake>, amount: u64) -> Result<()> {
        let staking = &mut ctx.accounts.staking_pool;
        let user_stake = &mut ctx.accounts.user_stake;
        let clock = Clock::get()?;

        // Update rewards (EVM: modifier updateReward)
        _update_rewards(staking, user_stake, clock.unix_timestamp)?;

        // Transfer tokens to vault
        token::transfer(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info(),
                Transfer {
                    from: ctx.accounts.user_token.to_account_info(),
                    to: ctx.accounts.staking_vault.to_account_info(),
                    authority: ctx.accounts.user.to_account_info(),
                },
            ),
            amount,
        )?;

        user_stake.amount = user_stake.amount.checked_add(amount)
            .ok_or(ErrorCode::Overflow)?;
        staking.total_staked = staking.total_staked.checked_add(amount)
            .ok_or(ErrorCode::Overflow)?;

        emit!(Staked {
            user: ctx.accounts.user.key(),
            amount,
        });
        Ok(())
    }

    /// Claim staking rewards
    /// EVM equivalent: claimReward()
    pub fn claim_rewards(ctx: Context<ClaimRewards>) -> Result<()> {
        let staking = &mut ctx.accounts.staking_pool;
        let user_stake = &mut ctx.accounts.user_stake;
        let clock = Clock::get()?;

        _update_rewards(staking, user_stake, clock.unix_timestamp)?;

        let reward = user_stake.rewards_earned;
        if reward > 0 {
            user_stake.rewards_earned = 0;
            // Mint reward tokens via PDA signer
            // ... (CPI mint_to with pool PDA authority)
        }

        emit!(RewardsClaimed {
            user: ctx.accounts.user.key(),
            amount: reward,
        });
        Ok(())
    }


    // ═══════════════════════════════════════════════════
    // --WRITE (custom migration)
    // ═══════════════════════════════════════════════════

    pub fn initialize___write(ctx: Context<InitializeWrite>) -> Result<()> {
        // TODO: Implement --write initialization
        // Map your EVM constructor logic here
        Ok(())
    }

}
